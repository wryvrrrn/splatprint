placeholder lines/lines that need work are generally commented with #(WIP)

general:
- set up command line switches
- clean up junk files in project folder
- set up demo folder (normal and inverse test images, macro preview, in-game screenshot (first pass), repair macro preview, in-game screenshot (second pass))
- save flag? only takes screenshot image, outputs to a png (for editing a post that you've drawn in-game)

__main__.py:
- proper CLI argument setup

printpost.py:
- first figure out how the hell this array stuff works; trying to get first line returns like, 3x120 or something????
	- it was because turning an rgb image into an np array generates a 3d array you dumbass
	- however processed image to array (both norm/inv and repair) are both 2d arrays
	- repair_array[0] returns 120-long array filled with 0, 1, or 2; can go from repair_array[0] to repair_array[319]
	- same for nrm/inv_array[0], just with true/false
	- in both cases, checking for 0s (numpy.nonzeros) shows all non-printing pixels
- fast mode
	#overhauls the whole fucking thing fr, new branch stuff
	#keep the old version as cautious but get rid of the obsolete args
	
	#store cursor y value as cursor_index in currently processing column array
	#rotating image 90 degrees clockwise, so cursor_index starts at 119? since that's the top left
	cursor_index = 119
	
	#for loop iterating across each column in array
	for crtrow in array:    #row of 90 degree rotated array, so each column
		#for current column, find index of first and last printable pixel (black for nrm, white for inverse, b/w for repair), get locations
		#if none, send right input, check next column
		printablepx = np.nonzero(crtrow)
		printpxlen = np.size(printablepx)    #how many printable pixels are in the column

		if printpxlen == 0:    #check how many nonzero values are in the current row
			send right input
		
		#if one, move to pixel, then print pixel (printtopixel() is defined below)
		if printpxlen == 1:
			#define movetopixel() (move cursor to specified pixel in column)
			def movetopixel(cursor_index, pixel_index):
				if pixel_index < cursor_index:			#pixel is below cursor
					#move cursor
					while cursor_index != pixel_index:
						send down input                 #rotating image 90 degrees clockwise, end of column array is top of image
						cursor_index -= 1               #move cursor down
					if cursor_index == 0:               #align if cursor moved to bottom of column
						send multiple down inputs
				if pixel_index > cursor_index:			#pixel is above cursor
					while cursor_index != pixel_index:
						send up input
						cursor_index += 1
					if cursor_index == 119:             #align if cursor moved to top of column
						send multiple up inputs
				return                 
			#move to pixel, then print
			movetopixel(cursor_index, pixel_index))
			printpixel(array, cursor_index, repair, inverse)
			send right input    #move to next column
		
		
		#if more than 2+
		if printpxlen > 1:
			#find whether the top or bottom pixel is closest to the cursor y value
			max_index = np.max(np.nonzero(crtrow))
			min_index = np.min(np.nonzero(crtrow))
			if cursor_index == min_index:
				closest_index = min_index
				furthest_index = max_index
				printdir = 1                           #1 == printing upwards, -1 == downwards
			elif cursor_index == max_index:
				closest_index = max_index
				furthest_index = min_index
				printdir = -1
			elif min_index > cursor_index and max_index > cursor_index:    #cursor is below pixels to print
				closest_index = min_index
				furthest_index = max_index
				printdir = 1
			elif min_index < cursor_index and max_index < cursor_index:    #cursor is above pixels to print
				closest_index = max_index
				furthest_index = min_index
				printdir = -1
			else:                                                          #cursor is in middle
				if cursor_index - min_index > (max_index - min_index)/2:
					closest_index = max_index
					furthest_index = min_index
					printdir = -1
				else:
					closest_index = min_index
					furthest_index = max_index
					printdir = 1
			#move cursor
			movetopixel(cursor_index, closest_index)
		
			#define printpixel() (print function)
			def printpixel(array, cursor_index, repair, inverse):
				if repair:
					get array value at cursor_index
					if value == 1:
						erase
					elif value == 2:
						ink
				elif inverse:    #printpixel() should only be called for nonzero pixels
					erase
				else:
					ink
				return
		
			#print pixels in column
			while cursor_index != furthest_pixel_index:
				if cursor_index is in printablepx:    #np array
				if np.any((np.isin(printablepx, cursor_index))):
					printpixel(array, cursor_index, repair, inverse)
				if printdir = -1:
					send down input
					cursor_index -= 1
				else:
					send up input
					cursor_index += 1			

			#at end of line
			if cursor_index is in printablepx:
				printpixel(array, cursor_index, repair, inverse)
			if cursor_index == 0 and printdir == -1:      #cursor is at bottom of column, printing downwards
				send extra down inputs                    #so dropped inputs don't botch the whole thing, just to be safe
			elif cursor_index == 119 and printdir == 1:   #cursor is at top of column, printing up
				send extra up inputs
			
			send right input    #move to next column
		
	#upper left, screenshot, minus (shared with cautious mode, don't need to write)
	

macropreview.py:
- have skip color adapt to bg color on repair
- for fast mode
	overlaps for cursor path
	first pass blue;
	then, if blue and cursor input on pixel, change to red (second pass color)
	if red and cursor input on pixel, change to green
	shouldn't have more than 3 overlapped pixels though
	store A + B inputs in a separate array, overlay with Pillow? (adjustable transparency)